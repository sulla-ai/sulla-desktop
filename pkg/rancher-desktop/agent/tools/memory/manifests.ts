import type { ToolManifest } from '../registry';

export const memoryToolManifests: ToolManifest[] = [
  {
    name: 'article_create',
    description: 'Create a new article in the knowledge base with the specified content and metadata.',
    category: 'memory',
    schemaDef: {
    slug: { type: 'string', description: "Unique slug identifier for the article" },
    title: { type: 'string', description: "Title of the article" },
    content: { type: 'string', description: "Full markdown content of the article" },
    section: { type: 'string', optional: true, description: "Section this article belongs to" },
    category: { type: 'string', optional: true, description: "Category within the section" },
    tags: { type: 'string', optional: true, default: "", description: "Comma-separated list of tags for the article" },
    order: { type: 'string', optional: true, default: "100", description: "Order field for sorting (string)" },
    locked: { type: 'boolean', optional: true, default: false, description: "Whether the article is locked for editing" },
    author: { type: 'string', optional: true, default: "Jonathon Byrdziak", description: "Author of the article" },
    related_slugs: { type: 'string', optional: true, default: "", description: "Comma-separated legacy related slugs" },
    mentions: { type: 'string', optional: true, default: "", description: "Comma-separated slugs/entities mentioned" },
    related_entities: { type: 'string', optional: true, default: "", description: "Comma-separated related entity IDs/names" },
  },
    operationTypes: ['create'],
    loader: () => import('./article_create'),
  },
  {
    name: 'article_delete',
    description: 'Delete an article from the knowledge base by its slug. This action is permanent.',
    category: 'memory',
    schemaDef: {
    slug: { type: 'string', description: "Slug of the article to delete" },
  },
    operationTypes: ['delete'],
    loader: () => import('./article_delete'),
  },
  {
    name: 'article_find',
    description: 'Find and retrieve a single article by its slug. Returns the full article metadata and content.',
    category: 'memory',
    schemaDef: {
    slug: { type: 'string', description: "The unique slug identifier of the article to find" },
  },
    operationTypes: ['read'],
    loader: () => import('./article_find'),
  },
  {
    name: 'article_find_related',
    description: 'Find articles related to a given slug via graph relationships. Returns up to 10 related articles by default.',
    category: 'memory',
    schemaDef: {
    slug: { type: 'string', description: "The slug of the article to find related articles for" },
    relType: { type: 'string', optional: true, default: "MENTIONS", description: "Type of relationship to search (e.g., MENTIONS)" },
    limit: { type: 'number', optional: true, default: 10, description: "Maximum number of related articles to return" },
  },
    operationTypes: ['read'],
    loader: () => import('./article_find_related'),
  },
  {
    name: 'article_list',
    description: 'List articles ordered by their order field. Returns article metadata without full content.',
    category: 'memory',
    schemaDef: {
    limit: { type: 'number', optional: true, default: 10, description: "Maximum number of articles to return" },
  },
    operationTypes: ['read'],
    loader: () => import('./article_list'),
  },
  {
    name: 'article_related',
    description: 'Get related articles by graph relationship.',
    category: 'memory',
    schemaDef: {
    slug: { type: 'string', description: "The slug of the article" },
    relationship: { type: 'string', optional: true, description: "Relationship type (default: MENTIONS)" },
  },
    operationTypes: ['read'],
    loader: () => import('./article_related'),
  },
  {
    name: 'article_search',
    description: 'Perform semantic search on articles by query. Returns matching articles with metadata and relevance scores.',
    category: 'memory',
    schemaDef: {
    query: { type: 'string', description: "The search query to find relevant articles" },
    limit: { type: 'number', optional: true, default: 5, description: "Maximum number of results to return" },
    tag: { type: 'string', optional: true, description: "Optional tag filter to narrow search results" },
  },
    operationTypes: ['read'],
    loader: () => import('./article_search'),
  },
  {
    name: 'article_update',
    description: 'Update an existing article',
    category: 'memory',
    schemaDef: {
    slug: { type: 'string', description: "Slug of the article to update" },
    title: { type: 'string', optional: true, description: "New title for the article" },
    content: { type: 'string', optional: true, description: "New full markdown content (replaces existing)" },
    section: { type: 'string', optional: true, description: "New section" },
    category: { type: 'string', optional: true, description: "New category" },
    tags: { type: 'array', items: { type: 'string' }, optional: true, description: "New array of tags" },
    order: { type: 'string', optional: true, description: "New order field" },
    locked: { type: 'boolean', optional: true, description: "New locked status" },
    author: { type: 'string', optional: true, description: "New author" },
    related_slugs: { type: 'array', items: { type: 'string' }, optional: true, description: "New array of related slugs" },
    mentions: { type: 'array', items: { type: 'string' }, optional: true, description: "New array of mentions" },
    related_entities: { type: 'array', items: { type: 'string' }, optional: true, description: "New array of related entities" },
  },
    operationTypes: ['update'],
    loader: () => import('./article_update'),
  },
];
